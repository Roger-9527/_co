# 第一章
## 1. 基本邏輯閘 (Basic Logic Gates)
* Not 閘  
  邏輯思考：  
  * 0 → 1  
  * 1 → 0  

  `if in = 0 then out = 1 else out = 0`  

  功能：  
  將輸入訊號反轉，輸入為 0 則輸出為 1，輸入為 1 則輸出為 0  

* And 閘  
  只有在兩個輸入皆為 1 時，輸出才為 1  
  `if a = 1 and b = 1 then out = 1 else out = 0`  

* Or (或閘)  
  只要任一個輸入為 1，輸出即為 1  
  `if a = 1 or b = 1 then out = 1 else out = 0`  

* Xor (互斥或閘)  
  當兩個輸入不同時，輸出為 1；  
  若兩個輸入相同（皆為 0 或皆為 1），輸出為 0  

```text
Input A  Input B  And  Or  Xor
------------------------------
   0        0      0    0    0
   0        1      0    1    1
   1        0      0    1    1
   1        1      1    1    0
   # 第二章
## 1. 基礎加法器 (The Adders)
* HalfAdder (半加器)  
  計算 a + b  
  輸入：a, b  
  輸出：  
  `sum（總和）：當前位元的結果`  
  `carry（進位）：是否產生進位`  

  原理：  
  `1 + 0 = 1（sum = 1, carry = 0）`  
  `1 + 1 = 10（二進位的 2，sum = 0, carry = 1）`  

  組成：  
  一個 Xor 閘（計算 sum）＋ 一個 And 閘（計算 carry）  

  缺點：  
  無法處理「從前一位傳來的進位」，因此只能用於最低位元的加法。  

* FullAdder (全加器)  
  為了解決半加器的限制，全加器多了一個「進位輸入」  

  功能：  
  計算 a + b + c（c 為前一位的進位）  

  輸入：  
  a, b, c（input carry）  

  輸出：  
  `sum`  
  `carry`  

  組成：  
  由 2 個 HalfAdder 與 1 個 Or 閘組成  

  意義：  
  多位元加法的基本單元。將多個 FullAdder 串接，即可完成大數字的加法運算。  

## 2. 16-bit 運算單元
* Add16  
  功能：  
  計算兩個 16 位元數字的相加（out = a + b）  

  實作方式：  
  將 16 個 FullAdder 依序排列  
  * 第 0 位的 carry 輸出連接到第 1 位的 carry 輸入  
  * 依此類推，直到最高位  

  說明：  
  這種設計在硬體中稱為「漣波進位加法器（Ripple Carry Adder）」，  
  因為進位會像波浪一樣，從最低位逐步傳遞到最高位。  

* Inc16  
  功能：  
  將輸入的數字加 1（out = in + 1）  

  用途：  
  這是電腦中最常用的運算之一，  
  主要用於 Program Counter（PC）。  
  電腦每執行完一條指令後，PC 需要加 1 以指向下一條指令。  

  實作方式：  
  使用一個 Add16，  
  其中一個輸入為 in，另一個輸入固定為 1。  

## 3. 電腦的大腦
* ALU  
  前面學過的所有元件（Add、And、Or、Not 等）  
  最終都會被整合封裝在 ALU 中。  

  功能：  
  根據「控制訊號（Control Bits）」決定要對輸入資料執行哪一種運算  
  （加法、減法、And、Or、反轉等）。  

  輸入：  
  `x, y（兩個 16-bit 資料）`  
  `zx, nx, zy, ny, f, no（6 個控制位元，為 Hack 電腦架構的特徵）`  

  輸出：  
  `out（運算結果）`  
  `zr（Zero flag）：結果是否為 0`  
  `ng（Negative flag）：結果是否為負數`  

  運作流程：  
  ALU 內部大量使用 Mux（多工器）來控制資料流向  
  * 控制位元 f：決定執行算術運算（Add）或邏輯運算（And）  
  * 控制位元 no：決定是否將最終結果進行反轉（Not）  

總結：  
1. HalfAdder（只能處理單一位元加法）  
2. FullAdder（可處理進位）  
3. Add16（串接 16 個 FullAdder）  
4. ALU（結合 Add16 與 And16／Or16，形成萬用運算單元）  

[作業](https://github.com/Luo051227/_co/tree/main/%E6%9C%9F%E4%B8%AD/2)
[AI](https://gemini.google.com/share/e8517dddc71d)
# 第三章
## 1. 基礎儲存單元
* Bit  
  只能儲存一個 0 或 1  

  功能：  
  能記住上一個時間點的狀態  

  原理：  
  由一個 DFF（Data Flip-Flop，資料正反器）與一個 Mux（多工器）組成  

  `load = 1` 時，寫入新值  
  `load = 0` 時，Mux 會將 DFF 的輸出回饋到輸入，形成迴圈，維持原本的值  

* Register  
  CPU 運算時使用的基本儲存單元  

  結構：  
  由 16 個 Bit 並排組成（在 Hack 電腦架構中）  

  功能：  
  可儲存一個 16-bit 的字組（Word），例如整數或記憶體位址  

  運作方式：  
  16 個 Bit 共用同一個 load 訊號，  
  當 load = 1 時，16 個 Bit 會同時更新  

## 2. RAM（隨機存取記憶體）系列
`遞迴（Recursive）結構，利用小型 RAM 組合出大型 RAM`

* RAM8  
  容量：  
  8 個 16-bit 暫存器  

  定址（Address）：  
  3 個位元（2^3 = 8），範圍為 000 到 111  

  原理：  
  * 輸入（DMux）：  
    使用 address 將輸入訊號導向正確的 Register  
  * 輸出（Mux）：  
    使用 address 選出正確 Register 的輸出  

* RAM64  
  容量：  
  64 個暫存器（由 8 個 RAM8 組成）  

  定址：  
  6 個位元（2^6 = 64）  

  原理：  
  * 高 3 位 address：選擇哪一個 RAM8  
  * 低 3 位 address：選擇該 RAM8 中的 Register  

* RAM512  
  容量：  
  512 個暫存器（由 8 個 RAM64 組成）  

  定址：  
  9 個位元  

  原理：  
  高 3 位選擇 RAM64，  
  低 6 位交由被選中的 RAM64 處理  

* RAM4K (4096)  
  容量：  
  4096 個暫存器（由 8 個 RAM512 組成）  

  定址：  
  12 個位元  

* RAM16K (16384)  
  容量：  
  16384 個暫存器（由 4 個 RAM4K 組成）  

  定址：  
  14 個位元  

  注意：  
  這是 Hack 電腦的主記憶體大小。  
  因為最上層是由 4 個 RAM4K 組成（而非 8 個），  
  因此使用 DMux4Way 與 Mux4Way 進行控制。  

## 3. 特殊功能暫存器
* PC  
  用來告訴 CPU「下一行程式碼的位置」  

  功能：  
  儲存下一條指令的記憶體位址  

  邏輯優先順序（由高到低）：  
  1. Reset：reset = 1 時，PC 歸零（跳到位址 0）  
  2. Load：load = 1 時，PC 設為輸入值（跳轉）  
  3. Inc：inc = 1 時，PC 值加 1  
  4. Hold：其餘情況維持原值  

## 總結
| 元件名稱 | 組成結構 | Address 位元數 | 功能描述 |
| :--- | :--- | :--- | :--- |
| **Bit** | `DFF` + `Mux` | 0 | 儲存 1 bit 資訊 |
| **Register** | 16 x `Bit` | 0 | 儲存 16 bit 數值 |
| **RAM8** | 8 x `Register` | 3 | 小型記憶體 |
| **RAM64** | 8 x `RAM8` | 6 | 中型記憶體 |
| **RAM512** | 8 x `RAM64` | 9 | 大型記憶體 |
| **RAM4K** | 8 x `RAM512` | 12 | 巨型記憶體 |
| **RAM16K** | 4 x `RAM4K` | 14 | Hack 主記憶體 |
| **PC** | `Register` + `Inc` | 0 | 程式計數器 |

[作業](https://github.com/Luo051227/_co/tree/main/%E6%9C%9F%E4%B8%AD/3)
[AI](https://gemini.google.com/share/343a93793658)

---

```markdown
# 第五章
## 1. Memory（記憶體）
Hack 的 Memory 是「記憶體映射裝置（Memory Map）」，  
不同位址對應不同硬體。  

結構：  
* RAM16K：0 ~ 16383  
* Screen：16384 ~ 24575  
* Keyboard：24576  

實作邏輯：  
* address[14] = 0 → RAM  
* address[14] = 1 且 address[13] = 0 → Screen  
* address[14] = 1 且 address[13] = 1 → Keyboard  

## 2. CPU（中央處理器）
核心元件：  
* ALU  
* A 暫存器  
* D 暫存器  
* PC  

指令解碼：  
* instruction[15] = 0 → A 指令  
* instruction[15] = 1 → C 指令  

## 3. Computer（整台電腦）
結構（馮．紐曼架構）：  
* ROM32K  
* CPU  
* Memory  

Reset：  
reset = 1 時，PC 歸零，程式重新執行  

## 總結
* Memory：重點在位址判斷  
* CPU：最困難，需清楚資料流  
* Computer：負責正確連接所有元件  

[作業](https://github.com/Luo051227/_co/tree/main/%E6%9C%9F%E4%B8%AD/5)
[AI](https://gemini.google.com/share/d22f4a1e0077)

